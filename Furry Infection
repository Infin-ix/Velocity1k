local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

--VV

local Window = Fluent:CreateWindow({
	Title = "Velocity1k | V0.1.3 | Furry Infection",
	SubTitle = "by narpyyy",
	TabWidth = 140,
	Size = UDim2.fromOffset(580, 420),
	Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
	Theme = "Rose",
	MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
	Home = Window:AddTab({ Title = "Home", Icon = "home" }),
	Main = Window:AddTab({ Title = "Scripts", Icon = "file-code" }),
	Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

do
	Fluent:Notify({
		Title = "Velocity1k",
		Content = "Thank you for using our hub!",
		SubContent = " ", -- Optional
		Duration = 5 -- Set to nil to make the notification not disappear
	})

	Tabs.Home:AddButton({
		Title = "Reset",
		Description = "Kills Your character",
		Callback = function()
			game.Players.LocalPlayer.Character:WaitForChild("Humanoid").Health = -5
		end
	})
	
	Tabs.Home:AddParagraph({
		Title = "Welcome, ".. game.Players.LocalPlayer.DisplayName,
		Content = " "
	})
	Tabs.Home:AddParagraph({
		Title = "UserID: ".. game.Players.LocalPlayer.UserId,
		Content = " "
	})
	Tabs.Home:AddParagraph({
		Title = "Default User: ".. game.Players.LocalPlayer.Name,
		Content = " "
	})

	Tabs.Main:AddButton({
		Title = "Hard Reset",
		Description = "Removes ur Torso and Humanoid",
		Callback = function()
			game.Players.LocalPlayer.Character.Humanoid:TakeDamage(math.huge)
			wait(0.1)
			game.Players.LocalPlayer.Character.Humanoid:Destroy()
			game.Players.LocalPlayer.Character.Torso:Destroy()
		end
	})

	Tabs.Main:AddToggle("GodToggle", {
		Title = "Sorta God?",
		Description = "Its like GodMode but if someone hits u, u die but doesn't show",
		Callback = function(Value)
			if Value == true then
				settings():GetService("NetworkSettings").IncomingReplicationLag = 1234
			else
				settings():GetService("NetworkSettings").IncomingReplicationLag = 0
			end
		end
	})
	
	local Clipon = false
	
	Tabs.Main:AddToggle("NoclipToggle", {
		Title = "Noclip",
		Description = "Look Ma! I can Phase Through Walls!",
		Callback = function(Value)
			if Value then
				Clipon = true
				game:GetService("RunService").Stepped:Connect(function()
					if Clipon then
						for a, b in pairs(workspace:GetChildren()) do
							if b.Name == game.Players.LocalPlayer.Name then
								for i, v in pairs(workspace[game.Players.LocalPlayer.Name]:GetChildren()) do
									if v:IsA("BasePart") then
										v.CanCollide = false
									end end end end
					end
				end)
			else
				Options.FLINGToggle:SetValue(false)
				Clipon = false
			end
		end
	})

	Tabs.Main:AddToggle("FLINGToggle", {
		Title = "FLING",
		Description = "Spins at 90000",
		Callback = function(Value)
			if Value == true then
				local Spin = Instance.new("BodyAngularVelocity")
				Spin.Name = "Spinning"
				Spin.Parent = game.Players.LocalPlayer.Character.Torso
				Spin.MaxTorque = Vector3.new(0, math.huge, 0)
				Spin.AngularVelocity = Vector3.new(0,90000,0)
				Options.NoclipToggle:SetValue(true)
			else
				if game.Players.LocalPlayer.Character.Torso:FindFirstChild("Spinning") then
					game.Players.LocalPlayer.Character.Torso.Spinning:Destroy()
				end
			end
		end
	})


	Tabs.Main:AddToggle("FullBrightToggle", {
		Title = "Full Bright",
		Description = "like xray but light",
		Callback = function(Value)
			if Value then
				local lgh = Instance.new("PointLight")
				lgh.Range = math.huge
				lgh.Brightness = 3
				lgh.Parent = game.Players.LocalPlayer.Character.Head
			else
				if game.Players.LocalPlayer.Character:WaitForChild("Head"):FindFirstChild("PointLight") then
					game.Players.LocalPlayer.Character.Head.PointLight:Destroy()
				end
			end
		end
	})

	local SSlider = Tabs.Main:AddSlider("SpeedSlider", {
		Title = "Speed",
		Description = "Slider that changes ur speed",
		Default = 16,
		Min = 16,
		Max = 42,
		Rounding = 1,
		Callback = function(Value)
			game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").WalkSpeed = Value
		end
	})
	local SSlider = Tabs.Main:AddSlider("HHSlider", {
		Title = "Hip Height Changer",
		Description = "Slider that changes ur Height",
		Default = 0,
		Min = 0,
		Max = 7,
		Rounding = 0.1,
		Callback = function(Value)
			game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").HipHeight = Value
		end
	})
	
	local FOVSlider = Tabs.Main:AddSlider("FOVSlider", {
		Title = "FOV",
		Description = "Slider that changes ur FOV",
		Default = game.Workspace.CurrentCamera.FieldOfView,
		Min = 70,
		Max = 120,
		Rounding = 1,
		Callback = function(Value)
			game.Workspace.CurrentCamera.FieldOfView = Value
		end
	})

--[[
	local Dropdown = Tabs.Main:AddDropdown("Dropdown", {
		Title = "Dropdown",
		Values = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen"},
		Multi = false,
		Default = 1,
	})

	Dropdown:SetValue("four")

	Dropdown:OnChanged(function(Value)
		print("Dropdown changed:", Value)
	end)



	local MultiDropdown = Tabs.Main:AddDropdown("MultiDropdown", {
		Title = "Dropdown",
		Description = "You can select multiple values.",
		Values = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen"},
		Multi = true,
		Default = {"seven", "twelve"},
	})

	MultiDropdown:SetValue({
		three = true,
		five = true,
		seven = false
	})

	MultiDropdown:OnChanged(function(Value)
		local Values = {}
		for Value, State in next, Value do
			table.insert(Values, Value)
		end
		print("Mutlidropdown changed:", table.concat(Values, ", "))
	end)



	local Colorpicker = Tabs.Main:AddColorpicker("Colorpicker", {
		Title = "Colorpicker",
		Default = Color3.fromRGB(96, 205, 255)
	})

	Colorpicker:OnChanged(function()
		print("Colorpicker changed:", Colorpicker.Value)
	end)

	Colorpicker:SetValueRGB(Color3.fromRGB(0, 255, 140))



	local TColorpicker = Tabs.Main:AddColorpicker("TransparencyColorpicker", {
		Title = "Colorpicker",
		Description = "but you can change the transparency.",
		Transparency = 0,
		Default = Color3.fromRGB(96, 205, 255)
	})

	TColorpicker:OnChanged(function()
		print(
			"TColorpicker changed:", TColorpicker.Value,
			"Transparency:", TColorpicker.Transparency
		)
	end)



	local Keybind = Tabs.Main:AddKeybind("Keybind", {
		Title = "KeyBind",
		Mode = "Toggle", -- Always, Toggle, Hold
		Default = "LeftControl", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

		-- Occurs when the keybind is clicked, Value is `true`/`false`
		Callback = function(Value)
			print("Keybind clicked!", Value)
		end,

		-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
		ChangedCallback = function(New)
			print("Keybind changed!", New)
		end
	})

	-- OnClick is only fired when you press the keybind and the mode is Toggle
	-- Otherwise, you will have to use Keybind:GetState()
	Keybind:OnClick(function()
		print("Keybind clicked:", Keybind:GetState())
	end)

	Keybind:OnChanged(function()
		print("Keybind changed:", Keybind.Value)
	end)

	task.spawn(function()
		while true do
			wait(1)

			-- example for checking if a keybind is being pressed
			local state = Keybind:GetState()
			if state then
				print("Keybind is being held down")
			end

			if Fluent.Unloaded then break end
		end
	end)

	Keybind:SetValue("MB2", "Toggle") -- Sets keybind to MB2, mode to Hold


	local Input = Tabs.Main:AddInput("Input", {
		Title = "Input",
		Default = "Default",
		Placeholder = "Placeholder",
		Numeric = false, -- Only allows numbers
		Finished = false, -- Only calls callback when you press enter
		Callback = function(Value)
			print("Input changed:", Value)
		end
	})

	Input:OnChanged(function()
		print("Input updated:", Input.Value)
	end)
]]--
end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game

InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
--[[
SaveManager:BuildConfigSection(Tabs.Settings)
]]--

Window:SelectTab(1)

Window:Dialog({
	Title = "Velocity1k",
	Content = "Script has been loaded.",
	Buttons = {
		{
			Title = "Ok",
			Callback = function()
				print("ok")
			end
		}
	}
})
-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()



game["Run Service"].Heartbeat:Connect(function()
	if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Health == 0 then
		--Options.FELAGToggle:SetValue(false)
		Options.FullBrightToggle:SetValue(false)
	end
end)
